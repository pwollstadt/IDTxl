<!DOCTYPE html>




<html lang="en">
  <head>
    <meta charset="utf-8" />
    
    <title>idtxl.stats &mdash; IDTxl 0.1 documentation</title>
    <meta name="description" content="">
    <meta name="author" content="">

    

<link rel="stylesheet" href="../../_static/css/basicstrap-base.css" type="text/css" />
<link rel="stylesheet" id="current-theme" href="../../_static/css/bootstrap3/bootswatch-spacelab.css" type="text/css" />
<link rel="stylesheet" id="current-adjust-theme" href="../../_static/css/adjust_theme/bootswatch-spacelab.css" type="text/css" />

<link rel="stylesheet" href="../../_static/css/font-awesome.min.css">

<style type="text/css">
  body {
    padding-top: 60px;
    padding-bottom: 40px;
  }
</style>

<link rel="stylesheet" href="../../_static/css/basicstrap.css" type="text/css" />
<link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
<script type="text/javascript">
  var DOCUMENTATION_OPTIONS = {
            URL_ROOT:    '../../',
            VERSION:     '0.1',
            COLLAPSE_INDEX: false,
            FILE_SUFFIX: '.html',
            HAS_SOURCE:  true
  };
</script>
    <script type="text/javascript" src="../../_static/js/jquery.min.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/js/bootstrap3.min.js"></script>
<script type="text/javascript" src="../../_static/js/jquery.cookie.min.js"></script>
<script type="text/javascript" src="../../_static/js/basicstrap.js"></script>
<script type="text/javascript">
</script>
    <link rel="top" title="IDTxl 0.1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div id="navbar-top" class="navbar navbar-fixed-top navbar-default" role="navigation" aria-label="top navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../../index.html">IDTxl 0.1 documentation</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav navbar-right">

            
              <li><a href="../../py-modindex.html" title="Python Module Index" >modules </a></li>
              <li><a href="../../genindex.html" title="General Index" accesskey="I">index </a></li>
              <li><a href="../index.html" accesskey="U">Module code</a></li>
            

            <li class="visible-xs">
                <form class="search form-search form-inline navbar-form navbar-right sp-searchbox" action="../../search.html" method="get">
                  <div class="input-append input-group">
                    <input type="text" class="search-query form-control" name="q" placeholder="Search...">
                    <span class="input-group-btn">
                    <input type="submit" class="btn" value="Go" />
                    </span>
                  </div>
                  <input type="hidden" name="check_keywords" value="yes" />
                  <input type="hidden" name="area" value="default" />
                </form>
            </li>

            

          </ul>

        </div>
      </div>
    </div>
    

    <!-- container -->
    <div class="container">

      <!-- row -->
      <div class="row">
        
        

        <div class="col-md-9" id="content-wrapper">
          <div class="document" role="main">
            <div class="documentwrapper">
              <div class="bodywrapper">
                <div class="body">
                  
  <h1>Source code for idtxl.stats</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;Provide statistics functions.</span>

<span class="sd">Created on Mon Mar  7 18:13:27 2016</span>

<span class="sd">@author: patricia</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">idtxl_utils</span> <span class="k">as</span> <span class="n">utils</span>

<span class="n">VERBOSE</span> <span class="o">=</span> <span class="bp">True</span>


<div class="viewcode-block" id="network_fdr"><a class="viewcode-back" href="../../idtxl.html#idtxl.stats.network_fdr">[docs]</a><span class="k">def</span> <span class="nf">network_fdr</span><span class="p">(</span><span class="n">settings</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="n">results</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform FDR-correction on results of network inference.</span>

<span class="sd">    Perform correction of the false discovery rate (FDR) after network</span>
<span class="sd">    analysis. FDR correction can either be applied at the target level</span>
<span class="sd">    (by correcting omnibus p-values) or at the single-link level (by correcting</span>
<span class="sd">    p-values of individual links between single samples and the target).</span>

<span class="sd">    Input can be a list of partial results to combine results from parallel</span>
<span class="sd">    analysis.</span>

<span class="sd">    References:</span>

<span class="sd">    - Genovese, C.R., Lazar, N.A., &amp; Nichols, T. (2002). Thresholding of</span>
<span class="sd">      statistical maps in functional neuroimaging using the false discovery</span>
<span class="sd">      rate. Neuroimage, 15(4), 870-878.</span>

<span class="sd">    Args:</span>
<span class="sd">        settings : dict [optional]</span>
<span class="sd">            parameters for statistical testing with entries:</span>

<span class="sd">            - alpha_fdr : float [optional] - critical alpha level</span>
<span class="sd">              (default=0.05)</span>
<span class="sd">            - correct_by_target : bool [optional] - if true correct p-values on</span>
<span class="sd">              on the target level (omnibus test p-values), otherwise correct</span>
<span class="sd">              p_values for individual variables (sequential max stats p-values)</span>
<span class="sd">              (default=True)</span>
<span class="sd">            - fdr_constant : int [optional] - choose one of two constants used</span>
<span class="sd">              for calculating the FDR-thresholds according to Genovese (2002):</span>
<span class="sd">              1 will divide alpha by 1, 2 will divide alpha by the sum_i(1/i);</span>
<span class="sd">              see the paper for details on the assumptions (default=2)</span>

<span class="sd">        results : list of dicts</span>
<span class="sd">            network inference results from .analyse_network methods, where each</span>
<span class="sd">            dict entry represents results for one target node</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict</span>
<span class="sd">            input results structure pruned of non-significant links.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">settings</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">settings</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Set defaults and get parameters from settings dictionary</span>
    <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alpha_fdr&#39;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alpha_fdr&#39;</span><span class="p">]</span>
    <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;correct_by_target&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">correct_by_target</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;correct_by_target&#39;</span><span class="p">]</span>
    <span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;fdr_constant&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">constant</span> <span class="o">=</span> <span class="n">settings</span><span class="p">[</span><span class="s1">&#39;fdr_constant&#39;</span><span class="p">]</span>

    <span class="c1"># Combine results into single results dict (this creates a copy).</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">combine_results</span><span class="p">(</span><span class="o">*</span><span class="n">results</span><span class="p">)</span>

    <span class="c1"># Collect significant source variables for all targets. Either correct</span>
    <span class="c1"># p-value of whole target (all candidates), or correct p-value of</span>
    <span class="c1"># individual source variables. Use targets with significant input only</span>
    <span class="c1"># (determined by the omnibus test).</span>
    <span class="n">pval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">target_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">n_perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">cands</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">correct_by_target</span><span class="p">:</span>  <span class="c1"># whole target</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="s1">&#39;omnibus_sign&#39;</span><span class="p">]:</span>
                <span class="n">pval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pval</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="s1">&#39;omnibus_pval&#39;</span><span class="p">])</span>
                <span class="n">target_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_idx</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
                <span class="n">n_perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_perm</span><span class="p">,</span>
                                   <span class="n">res</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="s1">&#39;settings&#39;</span><span class="p">][</span><span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># individual variables</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">res</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">res</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="s1">&#39;omnibus_sign&#39;</span><span class="p">]:</span>
                <span class="n">n_sign</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="s1">&#39;selected_sources_pval&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
                <span class="n">pval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pval</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="s1">&#39;selected_sources_pval&#39;</span><span class="p">])</span>
                <span class="n">target_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_idx</span><span class="p">,</span>
                                       <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_sign</span><span class="p">)</span> <span class="o">*</span> <span class="n">target</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">cands</span> <span class="o">=</span> <span class="n">cands</span> <span class="o">+</span> <span class="n">res</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="s1">&#39;selected_vars_sources&#39;</span><span class="p">]</span>
                <span class="n">n_perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_perm</span><span class="p">,</span>
                                   <span class="n">res</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="s1">&#39;settings&#39;</span><span class="p">][</span><span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">pval</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;No links in final results. Return ...&#39;</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># Sort all p-values in ascending order.</span>
    <span class="n">sort_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">pval</span><span class="p">)</span>
    <span class="n">pval</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="c1"># Calculate threshold</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">pval</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="n">constant</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># pick the requested constant (see Genovese, p.872)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span>
            <span class="n">const</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span>  <span class="c1"># aprx. harmonic sum with Euler&#39;s number</span>
    <span class="k">elif</span> <span class="n">constant</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># This is less strict than the other one and corresponds to a</span>
        <span class="c1"># Bonoferroni-correction for the first p-value, however, it makes more</span>
        <span class="c1"># strict assumptions on the distribution of p-values, while constant 2</span>
        <span class="c1"># works for any joint distribution of the p-values.</span>
        <span class="n">const</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">thresh</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">/</span> <span class="n">const</span>

    <span class="c1"># If the number of permutations for calculating p-values for individual</span>
    <span class="c1"># variables is too low, return without performing any correction.</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_perm</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;WARNING: Number of permutations (&#39;&#39;n_perm_max_seq&#39;&#39;) for at &#39;</span>
              <span class="s1">&#39;least one target is too low to allow for FDR correction &#39;</span>
              <span class="s1">&#39;(FDR-threshold: {0:.4f}, min. theoretically possible p-value: &#39;</span>
              <span class="s1">&#39;{1}).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thresh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="n">n_perm</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">None</span>

    <span class="c1"># Compare data to threshold.</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="n">pval</span> <span class="o">&lt;=</span> <span class="n">thresh</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">sign</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">first_false</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">sign</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sign</span><span class="p">[</span><span class="n">first_false</span><span class="p">:]</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># avoids false positives due to equal pvals</span>

    <span class="c1"># Go over list of all candidates and remove them from the results dict.</span>
    <span class="n">sign</span> <span class="o">=</span> <span class="n">sign</span><span class="p">[</span><span class="n">sort_idx</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sign</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sign</span><span class="p">[</span><span class="n">s</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">correct_by_target</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">target_idx</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="n">res</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;selected_vars_full&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;selected_vars_target&#39;</span><span class="p">]</span>
                <span class="n">res</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;selected_sources_te&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">res</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;selected_sources_pval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">res</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;selected_vars_sources&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">res</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;omnibus_pval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">res</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;omnibus_sign&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">target_idx</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="n">cand</span> <span class="o">=</span> <span class="n">cands</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                <span class="n">cand_ind</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;selected_vars_sources&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cand</span><span class="p">)</span>
                <span class="n">res</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;selected_vars_sources&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">cand_ind</span><span class="p">)</span>
                <span class="n">res</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;selected_sources_pval&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
                                    <span class="n">res</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;selected_sources_pval&#39;</span><span class="p">],</span> <span class="n">cand_ind</span><span class="p">)</span>
                <span class="n">res</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;selected_sources_te&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span>
                                    <span class="n">res</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;selected_sources_te&#39;</span><span class="p">],</span> <span class="n">cand_ind</span><span class="p">)</span>
                <span class="n">res</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;selected_vars_full&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span>
                                    <span class="n">res</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="s1">&#39;selected_vars_full&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cand</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="omnibus_test"><a class="viewcode-back" href="../../idtxl.html#idtxl.stats.omnibus_test">[docs]</a><span class="k">def</span> <span class="nf">omnibus_test</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform an omnibus test on identified conditional variables.</span>

<span class="sd">    Test the joint information transfer from all identified sources to the</span>
<span class="sd">    current value conditional on candidates in the target&#39;s past. To test for</span>
<span class="sd">    significance, this is repeated for shuffled realisations of the sources.</span>
<span class="sd">    The distribution of values from shuffled data is then used as test</span>
<span class="sd">    distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        analysis_setup : MultivariateTE instance</span>
<span class="sd">            information on the current analysis, can have an optional attribute</span>
<span class="sd">            &#39;settings&#39;, a dictionary with parameters for statistical testing:</span>

<span class="sd">            - n_perm_omnibus : int [optional] - number of permutations</span>
<span class="sd">              (default=500)</span>
<span class="sd">            - alpha_omnibus : float [optional] - critical alpha level</span>
<span class="sd">              (default=0.05)</span>
<span class="sd">            - permute_in_time : bool [optional] - generate surrogates by</span>
<span class="sd">              shuffling samples in time instead of shuffling whole replications</span>
<span class="sd">              (default=False)</span>

<span class="sd">        data : Data instance</span>
<span class="sd">            raw data</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance</span>
<span class="sd">        float</span>
<span class="sd">            the test&#39;s p-value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set defaults and get parameters from settings dictionary</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
    <span class="n">n_permutations</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_perm_omnibus&#39;</span><span class="p">]</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alpha_omnibus&#39;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alpha_omnibus&#39;</span><span class="p">]</span>
    <span class="n">permute_in_time</span> <span class="o">=</span> <span class="n">_check_permute_in_time</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
                                             <span class="n">n_permutations</span><span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;no. target sources: {0}, no. sources: {1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                    <span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_target</span><span class="p">),</span>
                                    <span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">)))</span>
    <span class="k">assert</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">,</span> <span class="s1">&#39;No sources to test.&#39;</span>

    <span class="c1"># Create temporary variables b/c realisations for sources and targets are</span>
    <span class="c1"># created on the fly, which is costly, so we want to re-use them after</span>
    <span class="c1"># creation. (This does not apply to the current value realisations).</span>
    <span class="n">cond_source_realisations</span> <span class="o">=</span> <span class="p">(</span><span class="n">analysis_setup</span>
                                <span class="o">.</span><span class="n">_selected_vars_sources_realisations</span><span class="p">)</span>
    <span class="n">cond_target_realisations</span> <span class="o">=</span> <span class="p">(</span><span class="n">analysis_setup</span>
                                <span class="o">.</span><span class="n">_selected_vars_target_realisations</span><span class="p">)</span>
    <span class="n">te_orig</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span>
                            <span class="n">var1</span><span class="o">=</span><span class="n">cond_source_realisations</span><span class="p">,</span>
                            <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span><span class="p">,</span>
                            <span class="n">conditional</span><span class="o">=</span><span class="n">cond_target_realisations</span><span class="p">)</span>

    <span class="c1"># Create the surrogate distribution by permuting the conditional sources.</span>
    <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;omnibus test, n_perm: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_permutations</span><span class="p">))</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    # Calculate TE in parallel for all permutations</span>
<span class="sd">    surr_cond_real = np.empty(</span>
<span class="sd">        (n_permutations * data.n_realisations(analysis_setup.current_value),</span>
<span class="sd">         len(analysis_setup.selected_vars_sources)))</span>
<span class="sd">    i_1 = 0</span>
<span class="sd">    i_2 = data.n_realisations(analysis_setup.current_value)</span>
<span class="sd">    for perm in range(n_permutations):</span>
<span class="sd">        if permute_over_replications:</span>
<span class="sd">            surr_cond_real[i_1:i_2, ] = data.permute_data(</span>
<span class="sd">                                    analysis_setup.current_value,</span>
<span class="sd">                                    analysis_setup.selected_vars_sources)[0]</span>
<span class="sd">        else:</span>
<span class="sd">            surr_cond_real[i_1:i_2, ] = _permute_realisations(</span>
<span class="sd">                                            cond_source_realisations,</span>
<span class="sd">                                            analysis_setup._replication_index)</span>
<span class="sd">        i_1 = i_2</span>
<span class="sd">        i_2 += data.n_realisations(analysis_setup.current_value)</span>
<span class="sd">        &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">is_analytic_null_estimator</span><span class="p">()</span> <span class="ow">and</span>
            <span class="n">permute_in_time</span><span class="p">):</span>
        <span class="c1"># Generate the surrogates analytically</span>
        <span class="n">surr_distribution</span> <span class="o">=</span> <span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span>
                             <span class="n">estimate_surrogates_analytic</span><span class="p">(</span>
                               <span class="n">n_perm</span><span class="o">=</span><span class="n">n_permutations</span><span class="p">,</span>
                               <span class="n">var1</span><span class="o">=</span><span class="n">cond_source_realisations</span><span class="p">,</span>
                               <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span><span class="p">,</span>
                               <span class="n">conditional</span><span class="o">=</span><span class="n">cond_target_realisations</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">surr_cond_real</span> <span class="o">=</span> <span class="n">_get_surrogates</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                                         <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
                                         <span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">,</span>
                                         <span class="n">n_permutations</span><span class="p">,</span>
                                         <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>

        <span class="n">surr_distribution</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate_mult</span><span class="p">(</span>
                            <span class="n">n_chunks</span><span class="o">=</span><span class="n">n_permutations</span><span class="p">,</span>
                            <span class="n">re_use</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;var2&#39;</span><span class="p">,</span> <span class="s1">&#39;conditional&#39;</span><span class="p">],</span>
                            <span class="n">var1</span><span class="o">=</span><span class="n">surr_cond_real</span><span class="p">,</span>
                            <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span><span class="p">,</span>
                            <span class="n">conditional</span><span class="o">=</span><span class="n">cond_target_realisations</span><span class="p">)</span>
    <span class="p">[</span><span class="n">significance</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span><span class="n">te_orig</span><span class="p">,</span> <span class="n">surr_distribution</span><span class="p">,</span>
                                          <span class="n">alpha</span><span class="p">,</span> <span class="s1">&#39;one_bigger&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">significance</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39; -- significant</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39; -- not significant</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">significance</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">,</span> <span class="n">te_orig</span></div>


<div class="viewcode-block" id="max_statistic"><a class="viewcode-back" href="../../idtxl.html#idtxl.stats.max_statistic">[docs]</a><span class="k">def</span> <span class="nf">max_statistic</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">candidate_set</span><span class="p">,</span> <span class="n">te_max_candidate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform maximum statistics for one candidate source.</span>

<span class="sd">    Test if a transfer entropy value is significantly bigger than the maximum</span>
<span class="sd">    values obtained from surrogates of all remanining candidates.</span>

<span class="sd">    Args:</span>
<span class="sd">        analysis_setup : MultivariateTE instance</span>
<span class="sd">            information on the current analysis, can have an optional attribute</span>
<span class="sd">            &#39;settings&#39;, a dictionary with parameters for statistical testing:</span>

<span class="sd">            - n_perm_max_stat : int [optional] - number of permutations</span>
<span class="sd">              (default=200)</span>
<span class="sd">            - alpha_max_stat : float [optional] - critical alpha level</span>
<span class="sd">              (default=0.05)</span>
<span class="sd">            - permute_in_time : bool [optional] - generate surrogates by</span>
<span class="sd">              shuffling samples in time instead of shuffling whole replications</span>
<span class="sd">              (default=False)</span>

<span class="sd">        data : Data instance</span>
<span class="sd">            raw data</span>
<span class="sd">        candidate_set : list of tuples</span>
<span class="sd">            list of indices of remaning candidates</span>
<span class="sd">        te_max_candidate : float</span>
<span class="sd">            transfer entropy value to be tested</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance</span>
<span class="sd">        float</span>
<span class="sd">            the test&#39;s p-value</span>
<span class="sd">        numpy array</span>
<span class="sd">            surrogate table</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set defaults and get parameters from settings dictionary</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
    <span class="n">n_perm</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_perm_max_stat&#39;</span><span class="p">]</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alpha_max_stat&#39;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alpha_max_stat&#39;</span><span class="p">]</span>
    <span class="n">_check_permute_in_time</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">)</span>
    <span class="k">assert</span><span class="p">(</span><span class="n">candidate_set</span><span class="p">),</span> <span class="s1">&#39;The candidate set is empty.&#39;</span>

    <span class="n">surr_table</span> <span class="o">=</span> <span class="n">_create_surrogate_table</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">candidate_set</span><span class="p">,</span>
                                         <span class="n">n_perm</span><span class="p">)</span>
    <span class="n">max_distribution</span> <span class="o">=</span> <span class="n">_find_table_max</span><span class="p">(</span><span class="n">surr_table</span><span class="p">)</span>
    <span class="p">[</span><span class="n">significance</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span><span class="n">statistic</span><span class="o">=</span><span class="n">te_max_candidate</span><span class="p">,</span>
                                          <span class="n">distribution</span><span class="o">=</span><span class="n">max_distribution</span><span class="p">,</span>
                                          <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                          <span class="n">tail</span><span class="o">=</span><span class="s1">&#39;one_bigger&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">significance</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">,</span> <span class="n">surr_table</span></div>


<div class="viewcode-block" id="max_statistic_sequential"><a class="viewcode-back" href="../../idtxl.html#idtxl.stats.max_statistic_sequential">[docs]</a><span class="k">def</span> <span class="nf">max_statistic_sequential</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform sequential maximum statistics for a set of candidate sources.</span>

<span class="sd">    Test if sorted transfer entropy (TE) values are significantly bigger than</span>
<span class="sd">    their respective counterpart obtained from surrogates of all remanining</span>
<span class="sd">    candidates: test if the biggest TE is bigger than the distribution</span>
<span class="sd">    of biggest TE surrogate values; test if the 2nd biggest TE is bigger than</span>
<span class="sd">    the distribution of 2nd biggest surrogate TE values; ...</span>
<span class="sd">    Stop comparison if a TE value is non significant, all smaller values are</span>
<span class="sd">    considered non-significant as well.</span>

<span class="sd">    This function will re-use the surrogate table created in the last min-stats</span>
<span class="sd">    round if that table is in the analysis_setup. This saves the complete</span>
<span class="sd">    calculation of surrogates for this statistic.</span>

<span class="sd">    Args:</span>
<span class="sd">        analysis_setup : MultivariateTE instance</span>
<span class="sd">            information on the current analysis, can have an optional attribute</span>
<span class="sd">            &#39;settings&#39;, a dictionary with parameters for statistical testing:</span>

<span class="sd">            - n_perm_max_seq : int [optional] - number of permutations</span>
<span class="sd">              (default=&#39;n_perm_min_stat&#39;|500)</span>
<span class="sd">            - alpha_max_seq : float [optional] - critical alpha level</span>
<span class="sd">              (default=0.05)</span>
<span class="sd">            - permute_in_time : bool [optional] - generate surrogates by</span>
<span class="sd">              shuffling samples in time instead of shuffling whole replications</span>
<span class="sd">              (default=False)</span>

<span class="sd">        data : Data instance</span>
<span class="sd">            raw data</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy array, bool</span>
<span class="sd">            statistical significance of each source</span>
<span class="sd">        numpy array, float</span>
<span class="sd">            the test&#39;s p-values for each source</span>
<span class="sd">        numpy array, float</span>
<span class="sd">            TE values for individual sources</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">n_permutations</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>  <span class="c1"># use the same n_perm as for min_stats if surr table is reused</span>
            <span class="n">n_permutations</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_min_stats_surr_table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_permutations</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>  <span class="c1"># is surr table is None, use default</span>
            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">500</span>
            <span class="n">n_permutations</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_perm_max_seq&#39;</span><span class="p">]</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alpha_max_seq&#39;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alpha_max_seq&#39;</span><span class="p">]</span>
    <span class="n">_check_permute_in_time</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_permutations</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">,</span> <span class="s1">&#39;No sources to test.&#39;</span>

    <span class="c1"># Calculate TE for each candidate in the conditional source set and sort</span>
    <span class="c1"># TE values.</span>
    <span class="n">candidate_realisations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">n_realisations</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">)</span> <span class="o">*</span>
                         <span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">conditional_realisations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">n_realisations</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">)</span> <span class="o">*</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">),</span>
                         <span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_full</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">i_1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i_2</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">n_realisations</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">conditional</span> <span class="ow">in</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">:</span>
        <span class="p">[</span><span class="n">temp_cond</span><span class="p">,</span> <span class="n">temp_cand</span><span class="p">]</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_separate_realisations</span><span class="p">(</span>
                                            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_full</span><span class="p">,</span>
                                            <span class="n">conditional</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">temp_cond</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">conditional_realisations</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">conditional_realisations</span><span class="p">[</span><span class="n">i_1</span><span class="p">:</span><span class="n">i_2</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">temp_cond</span>
        <span class="n">candidate_realisations</span><span class="p">[</span><span class="n">i_1</span><span class="p">:</span><span class="n">i_2</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">temp_cand</span>
        <span class="n">i_1</span> <span class="o">=</span> <span class="n">i_2</span>
        <span class="n">i_2</span> <span class="o">+=</span> <span class="n">data</span><span class="o">.</span><span class="n">n_realisations</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">)</span>

    <span class="n">individual_te</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate_mult</span><span class="p">(</span>
                            <span class="n">n_chunks</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">),</span>
                            <span class="n">re_use</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;var2&#39;</span><span class="p">],</span>
                            <span class="n">var1</span><span class="o">=</span><span class="n">candidate_realisations</span><span class="p">,</span>
                            <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span><span class="p">,</span>
                            <span class="n">conditional</span><span class="o">=</span><span class="n">conditional_realisations</span><span class="p">)</span>

    <span class="n">selected_vars_order</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">argsort_descending</span><span class="p">(</span><span class="n">individual_te</span><span class="p">)</span>
    <span class="n">individual_te_sorted</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sort_descending</span><span class="p">(</span><span class="n">individual_te</span><span class="p">)</span>

    <span class="c1"># Re-use or create surrogate table and sort it, this saves some time</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_min_stats_surr_table</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
            <span class="n">n_permutations</span> <span class="o">&lt;=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_min_stats_surr_table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">surr_table</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_min_stats_surr_table</span><span class="p">[:,</span> <span class="p">:</span><span class="n">n_permutations</span><span class="p">]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">)</span> <span class="o">==</span> <span class="n">surr_table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">surr_table</span> <span class="o">=</span> <span class="n">_create_surrogate_table</span><span class="p">(</span>
                                        <span class="n">analysis_setup</span><span class="p">,</span>
                                        <span class="n">data</span><span class="p">,</span>
                                        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">selected_vars_sources</span><span class="p">,</span>
                                        <span class="n">n_permutations</span><span class="p">)</span>
    <span class="n">max_distribution</span> <span class="o">=</span> <span class="n">_sort_table_max</span><span class="p">(</span><span class="n">surr_table</span><span class="p">)</span>

    <span class="c1"># Compare each TE value with the distribution of the same rank, starting</span>
    <span class="c1"># with the highest TE.</span>
    <span class="n">significance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">individual_te</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">pvalue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">individual_te</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">individual_te</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span><span class="n">individual_te_sorted</span><span class="p">[</span><span class="n">c</span><span class="p">],</span>
                              <span class="n">max_distribution</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="p">],</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">tail</span><span class="o">=</span><span class="s1">&#39;one_bigger&#39;</span><span class="p">)</span>
        <span class="n">significance</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span>
        <span class="n">pvalue</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="p">:</span>  <span class="c1"># break as soon as a candidate is no longer significant</span>
            <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s1">&#39;Stopping sequential max stats at candidate with rank &#39;</span>
                      <span class="s1">&#39;{0}.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="k">break</span>

    <span class="c1"># Get back original order and return results.</span>
    <span class="n">significance</span> <span class="o">=</span> <span class="n">significance</span><span class="p">[</span><span class="n">selected_vars_order</span><span class="p">]</span>
    <span class="n">pvalue</span> <span class="o">=</span> <span class="n">pvalue</span><span class="p">[</span><span class="n">selected_vars_order</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">significance</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">,</span> <span class="n">individual_te</span></div>


<div class="viewcode-block" id="min_statistic"><a class="viewcode-back" href="../../idtxl.html#idtxl.stats.min_statistic">[docs]</a><span class="k">def</span> <span class="nf">min_statistic</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">candidate_set</span><span class="p">,</span> <span class="n">te_min_candidate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Perform minimum statistics for one candidate source.</span>

<span class="sd">    Test if a transfer entropy value is significantly bigger than the minimum</span>
<span class="sd">    values obtained from surrogates of all remanining candidates.</span>

<span class="sd">    Args:</span>
<span class="sd">        analysis_setup : MultivariateTE instance</span>
<span class="sd">            information on the current analysis, can have an optional attribute</span>
<span class="sd">            &#39;settings&#39;, a dictionary with parameters for statistical testing:</span>

<span class="sd">            - n_perm_min_stat : int [optional] - number of permutations</span>
<span class="sd">              (default=500)</span>
<span class="sd">            - alpha_min_stat : float [optional] - critical alpha level</span>
<span class="sd">              (default=0.05)</span>
<span class="sd">            - permute_in_time : bool [optional] - generate surrogates by</span>
<span class="sd">              shuffling samples in time instead of shuffling whole replications</span>
<span class="sd">              (default=False)</span>

<span class="sd">        data : Data instance</span>
<span class="sd">            raw data</span>
<span class="sd">        candidate_set : list of tuples</span>
<span class="sd">            list of indices of remaning candidates</span>
<span class="sd">        te_min_candidate : float</span>
<span class="sd">            transfer entropy value to be tested</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance</span>
<span class="sd">        float</span>
<span class="sd">            the test&#39;s p-value</span>
<span class="sd">        numpy array</span>
<span class="sd">            surrogate table</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set defaults and get parameters from settings dictionary</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
    <span class="n">n_perm</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_perm_min_stat&#39;</span><span class="p">]</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alpha_min_stat&#39;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alpha_min_stat&#39;</span><span class="p">]</span>
    <span class="n">_check_permute_in_time</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">)</span>

    <span class="k">assert</span><span class="p">(</span><span class="n">candidate_set</span><span class="p">),</span> <span class="s1">&#39;The candidate set is empty.&#39;</span>

    <span class="n">surr_table</span> <span class="o">=</span> <span class="n">_create_surrogate_table</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">candidate_set</span><span class="p">,</span>
                                         <span class="n">n_perm</span><span class="p">)</span>
    <span class="n">min_distribution</span> <span class="o">=</span> <span class="n">_find_table_min</span><span class="p">(</span><span class="n">surr_table</span><span class="p">)</span>
    <span class="p">[</span><span class="n">significance</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span><span class="n">statistic</span><span class="o">=</span><span class="n">te_min_candidate</span><span class="p">,</span>
                                          <span class="n">distribution</span><span class="o">=</span><span class="n">min_distribution</span><span class="p">,</span>
                                          <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                          <span class="n">tail</span><span class="o">=</span><span class="s1">&#39;one_bigger&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">significance</span><span class="p">,</span> <span class="n">pvalue</span><span class="p">,</span> <span class="n">surr_table</span></div>


<div class="viewcode-block" id="mi_against_surrogates"><a class="viewcode-back" href="../../idtxl.html#idtxl.stats.mi_against_surrogates">[docs]</a><span class="k">def</span> <span class="nf">mi_against_surrogates</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Test estimated mutual information for significance against surrogate data.</span>

<span class="sd">    Shuffle realisations of the current value (point to be predicted) and re-</span>
<span class="sd">    calculate mutual information (MI) for shuffled data. The actual estimated</span>
<span class="sd">    MI is then compared against this distribution of MI values from surrogate</span>
<span class="sd">    data.</span>

<span class="sd">    Args:</span>
<span class="sd">        analysis_setup : MultivariateTE instance</span>
<span class="sd">            information on the current analysis, can have an optional attribute</span>
<span class="sd">            &#39;settings&#39;, a dictionary with parameters for statistical testing:</span>

<span class="sd">            - n_perm_mi : int [optional] - number of permutations</span>
<span class="sd">              (default=500)</span>
<span class="sd">            - alpha_mi : float [optional] - critical alpha level</span>
<span class="sd">              (default=0.05)</span>
<span class="sd">            - permute_in_time : bool [optional] - generate surrogates by</span>
<span class="sd">              shuffling samples in time instead of shuffling whole replications</span>
<span class="sd">              (default=False)</span>

<span class="sd">        data : Data instance</span>
<span class="sd">            raw data</span>

<span class="sd">    Returns:</span>
<span class="sd">        float</span>
<span class="sd">            estimated MI value</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance</span>
<span class="sd">        float</span>
<span class="sd">            p_value for estimated MI value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;n_perm_mi&#39;</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
    <span class="n">n_perm</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_perm_mi&#39;</span><span class="p">]</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alpha_mi&#39;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alpha_mi&#39;</span><span class="p">]</span>
    <span class="n">permute_in_time</span> <span class="o">=</span> <span class="n">_check_permute_in_time</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">)</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    surr_realisations = np.empty(</span>
<span class="sd">                        (data.n_realisations(analysis_setup.current_value) *</span>
<span class="sd">                         (n_perm + 1), 1))</span>
<span class="sd">    i_1 = 0</span>
<span class="sd">    i_2 = data.n_realisations(analysis_setup.current_value)</span>
<span class="sd">    # The first chunk holds the original data</span>
<span class="sd">    surr_realisations[i_1:i_2, ] = analysis_setup._current_value_realisations</span>
<span class="sd">    # Create surrogate data by shuffling the realisations of the current value.</span>
<span class="sd">    for perm in range(n_perm):</span>
<span class="sd">        i_1 = i_2</span>
<span class="sd">        i_2 += data.n_realisations(analysis_setup.current_value)</span>
<span class="sd">        # Check the permutation type for the current candidate.</span>
<span class="sd">        if permute_over_replications:</span>
<span class="sd">            surr_temp = data.permute_data(analysis_setup.current_value,</span>
<span class="sd">                                          [analysis_setup.current_value])[0]</span>
<span class="sd">        else:</span>
<span class="sd">            [real, repl_idx] = data.get_realisations(</span>
<span class="sd">                                            analysis_setup.current_value,</span>
<span class="sd">                                            [analysis_setup.current_value])</span>
<span class="sd">            surr_temp = _permute_realisations(real, repl_idx, perm_range)</span>
<span class="sd">        # Add current shuffled realisation to the array of all realisations for</span>
<span class="sd">        # parallel MI estimation.</span>
<span class="sd">        # surr_realisations[i_1:i_2, ] = surr_temp</span>
<span class="sd">        [real, repl_idx] = data.get_realisations(</span>
<span class="sd">                                            analysis_setup.current_value,</span>
<span class="sd">                                            [analysis_setup.current_value])</span>
<span class="sd">        &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">is_analytic_null_estimator</span><span class="p">()</span> <span class="ow">and</span>
            <span class="n">permute_in_time</span><span class="p">):</span>
        <span class="c1"># Generate the surrogates analytically</span>
        <span class="n">surr_dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span>
                     <span class="n">estimate_surrogates_analytic</span><span class="p">(</span>
                            <span class="n">n_perm</span><span class="o">=</span><span class="n">n_perm</span><span class="p">,</span>
                            <span class="n">var1</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span><span class="p">,</span>
                            <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_selected_vars_realisations</span><span class="p">,</span>
                            <span class="n">conditional</span><span class="o">=</span><span class="bp">None</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">surr_realisations</span> <span class="o">=</span> <span class="n">_get_surrogates</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                                            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
                                            <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">],</span>
                                            <span class="n">n_perm</span><span class="p">,</span>
                                            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>

        <span class="n">surr_dist</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate_mult</span><span class="p">(</span>
                            <span class="n">n_chunks</span><span class="o">=</span><span class="n">n_perm</span><span class="p">,</span>
                            <span class="n">re_use</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;var2&#39;</span><span class="p">,</span> <span class="s1">&#39;conditional&#39;</span><span class="p">],</span>
                            <span class="n">var1</span><span class="o">=</span><span class="n">surr_realisations</span><span class="p">,</span>
                            <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_selected_vars_realisations</span><span class="p">,</span>
                            <span class="n">conditional</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="n">orig_mi</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span>
                            <span class="n">var1</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span><span class="p">,</span>
                            <span class="n">var2</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_selected_vars_realisations</span><span class="p">,</span>
                            <span class="n">conditional</span><span class="o">=</span><span class="bp">None</span>
                            <span class="p">)</span>
    <span class="p">[</span><span class="n">significance</span><span class="p">,</span> <span class="n">p_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span><span class="n">statistic</span><span class="o">=</span><span class="n">orig_mi</span><span class="p">,</span>
                                           <span class="n">distribution</span><span class="o">=</span><span class="n">surr_dist</span><span class="p">,</span>
                                           <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                           <span class="n">tail</span><span class="o">=</span><span class="s1">&#39;one_bigger&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">orig_mi</span><span class="p">,</span> <span class="n">significance</span><span class="p">,</span> <span class="n">p_value</span><span class="p">]</span></div>


<div class="viewcode-block" id="unq_against_surrogates"><a class="viewcode-back" href="../../idtxl.html#idtxl.stats.unq_against_surrogates">[docs]</a><span class="k">def</span> <span class="nf">unq_against_surrogates</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Test the unique information in the PID estimate against surrogate data.</span>

<span class="sd">    Shuffle realisations of both sources individually and re-calculate PID,</span>
<span class="sd">    in particular the unique information from shuffled data. The original</span>
<span class="sd">    unique information is then compared against the distribution of values</span>
<span class="sd">    calculated from surrogate data.</span>

<span class="sd">    Args:</span>
<span class="sd">        analysis_setup : Partial_information_decomposition instance</span>
<span class="sd">            information on the current analysis, should have an Attribute</span>
<span class="sd">            &#39;settings&#39;, a dict with optional fields</span>

<span class="sd">            - n_perm : int [optional] - number of permutations (default=500)</span>
<span class="sd">            - alpha : float [optional] - critical alpha level (default=0.05)</span>
<span class="sd">            - permute_in_time : bool [optional] - generate surrogates by</span>
<span class="sd">              shuffling samples in time instead of shuffling whole replications</span>
<span class="sd">              (default=False)</span>

<span class="sd">        data : Data instance</span>
<span class="sd">            raw data</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict</span>
<span class="sd">            PID estimate from original data</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance of the unique information in source 1</span>
<span class="sd">        float</span>
<span class="sd">            p-value of the unique information in source 1</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance of the unique information in source 2</span>
<span class="sd">        float</span>
<span class="sd">            p-value of the unique information in source 2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get analysis settings and defaults.</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;n_perm&#39;</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
    <span class="n">n_perm</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_perm&#39;</span><span class="p">]</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span>
    <span class="n">_check_permute_in_time</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">)</span>

    <span class="c1"># Get realisations and estimate PID for orginal data</span>
    <span class="n">target_realisations</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span>
                                            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
                                            <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">source_1_realisations</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span>
                                        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
                                        <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">source_2_realisations</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span>
                                        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
                                        <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">sources</span><span class="p">[</span><span class="mi">1</span><span class="p">]])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">orig_pid</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_pid_estimator</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span>
                            <span class="n">settings</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
                            <span class="n">s1</span><span class="o">=</span><span class="n">source_1_realisations</span><span class="p">,</span>
                            <span class="n">s2</span><span class="o">=</span><span class="n">source_2_realisations</span><span class="p">,</span>
                            <span class="n">t</span><span class="o">=</span><span class="n">target_realisations</span><span class="p">)</span>

    <span class="c1"># Test unique information from source 1</span>
    <span class="n">surr_realisations</span> <span class="o">=</span> <span class="n">_get_surrogates</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                                        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
                                        <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                                        <span class="n">n_perm</span><span class="p">,</span>
                                        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>
    <span class="c1"># Calculate surrogate distribution for unique information of source 1.</span>
    <span class="c1"># Note: calling  .estimate_mult does not work here because the PID</span>
    <span class="c1"># estimator returns a dictionary not a single value. We have to get the</span>
    <span class="c1"># unique from the dictionary manually.</span>
    <span class="n">surr_dist_s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_perm</span><span class="p">)</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">surr_realisations</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_perm</span><span class="p">)</span>
    <span class="n">i_1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i_2</span> <span class="o">=</span> <span class="n">chunk_size</span>
    <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Testing unq information in s1&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_perm</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">perm {0} of {1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">))</span>
        <span class="n">pid_est</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_pid_estimator</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span>
                                <span class="n">settings</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
                                <span class="n">s1</span><span class="o">=</span><span class="n">surr_realisations</span><span class="p">[</span><span class="n">i_1</span><span class="p">:</span><span class="n">i_2</span><span class="p">,</span> <span class="p">:],</span>
                                <span class="n">s2</span><span class="o">=</span><span class="n">source_2_realisations</span><span class="p">,</span>
                                <span class="n">t</span><span class="o">=</span><span class="n">target_realisations</span>
                                <span class="p">)</span>
        <span class="n">surr_dist_s1</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">pid_est</span><span class="p">[</span><span class="s1">&#39;unq_s1&#39;</span><span class="p">]</span>
        <span class="n">i_1</span> <span class="o">=</span> <span class="n">i_2</span>
        <span class="n">i_2</span> <span class="o">+=</span> <span class="n">chunk_size</span>

    <span class="c1"># Test unique information from source 2</span>
    <span class="n">surr_realisations</span> <span class="o">=</span> <span class="n">_get_surrogates</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                                        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
                                        <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">sources</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                                        <span class="n">n_perm</span><span class="p">,</span>
                                        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>
    <span class="c1"># Calculate surrogate distribution for unique information of source 2.</span>
    <span class="n">surr_dist_s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_perm</span><span class="p">)</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">surr_realisations</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_perm</span><span class="p">)</span>
    <span class="n">i_1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i_2</span> <span class="o">=</span> <span class="n">chunk_size</span>
    <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Testing unq information in s2&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_perm</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">perm {0} of {1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">))</span>
        <span class="n">pid_est</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_pid_estimator</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span>
                                <span class="n">settings</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
                                <span class="n">s1</span><span class="o">=</span><span class="n">source_1_realisations</span><span class="p">,</span>
                                <span class="n">s2</span><span class="o">=</span><span class="n">surr_realisations</span><span class="p">[</span><span class="n">i_1</span><span class="p">:</span><span class="n">i_2</span><span class="p">,</span> <span class="p">:],</span>
                                <span class="n">t</span><span class="o">=</span><span class="n">target_realisations</span><span class="p">)</span>
        <span class="n">surr_dist_s2</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">pid_est</span><span class="p">[</span><span class="s1">&#39;unq_s2&#39;</span><span class="p">]</span>
        <span class="n">i_1</span> <span class="o">=</span> <span class="n">i_2</span>
        <span class="n">i_2</span> <span class="o">+=</span> <span class="n">chunk_size</span>
    <span class="p">[</span><span class="n">sign_1</span><span class="p">,</span> <span class="n">p_val_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span><span class="n">statistic</span><span class="o">=</span><span class="n">orig_pid</span><span class="p">[</span><span class="s1">&#39;unq_s1&#39;</span><span class="p">],</span>
                                     <span class="n">distribution</span><span class="o">=</span><span class="n">surr_dist_s1</span><span class="p">,</span>
                                     <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                     <span class="n">tail</span><span class="o">=</span><span class="s1">&#39;one_bigger&#39;</span><span class="p">)</span>
    <span class="p">[</span><span class="n">sign_2</span><span class="p">,</span> <span class="n">p_val_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span><span class="n">statistic</span><span class="o">=</span><span class="n">orig_pid</span><span class="p">[</span><span class="s1">&#39;unq_s2&#39;</span><span class="p">],</span>
                                     <span class="n">distribution</span><span class="o">=</span><span class="n">surr_dist_s2</span><span class="p">,</span>
                                     <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                     <span class="n">tail</span><span class="o">=</span><span class="s1">&#39;one_bigger&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">orig_pid</span><span class="p">,</span> <span class="n">sign_1</span><span class="p">,</span> <span class="n">p_val_1</span><span class="p">,</span> <span class="n">sign_2</span><span class="p">,</span> <span class="n">p_val_2</span><span class="p">]</span></div>


<div class="viewcode-block" id="syn_shd_against_surrogates"><a class="viewcode-back" href="../../idtxl.html#idtxl.stats.syn_shd_against_surrogates">[docs]</a><span class="k">def</span> <span class="nf">syn_shd_against_surrogates</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Test the shared/synergistic information in the PID estimate.</span>

<span class="sd">    Shuffle realisations of the target and re-calculate PID, in particular the</span>
<span class="sd">    synergistic and shared information from shuffled data. The original</span>
<span class="sd">    shared and synergistic information are then compared against the</span>
<span class="sd">    distribution of values calculated from surrogate data.</span>

<span class="sd">    Args:</span>
<span class="sd">        analysis_setup : Partial_information_decomposition instance</span>
<span class="sd">            information on the current analysis, should have an Attribute</span>
<span class="sd">            &#39;settings&#39;, a dict with optional fields</span>

<span class="sd">            - n_perm : int [optional] - number of permutations (default=500)</span>
<span class="sd">            - alpha : float [optional] - critical alpha level (default=0.05)</span>
<span class="sd">            - permute_in_time : bool [optional] - generate surrogates by</span>
<span class="sd">              shuffling samples in time instead of shuffling whole replications</span>
<span class="sd">              (default=False)</span>

<span class="sd">        data : Data instance</span>
<span class="sd">            raw data</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict</span>
<span class="sd">            PID estimate from original data</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance of the shared information</span>
<span class="sd">        float</span>
<span class="sd">            p-value of the shared information</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance of the synergistic information</span>
<span class="sd">        float</span>
<span class="sd">            p-value of the synergistic information</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get analysis settings and defaults.</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;n_perm&#39;</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
    <span class="n">n_perm</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;n_perm&#39;</span><span class="p">]</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span>
    <span class="n">_check_permute_in_time</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">)</span>

    <span class="c1"># Get realisations and estimate PID for original data</span>
    <span class="n">target_realisations</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span>
                                            <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
                                            <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">source_1_realisations</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span>
                                        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
                                        <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">source_2_realisations</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span>
                                        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
                                        <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">sources</span><span class="p">[</span><span class="mi">1</span><span class="p">]])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">orig_pid</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_pid_estimator</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span>
                            <span class="n">settings</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
                            <span class="n">s1</span><span class="o">=</span><span class="n">source_1_realisations</span><span class="p">,</span>
                            <span class="n">s2</span><span class="o">=</span><span class="n">source_2_realisations</span><span class="p">,</span>
                            <span class="n">t</span><span class="o">=</span><span class="n">target_realisations</span><span class="p">)</span>

    <span class="c1"># Test shared and synergistic information from both sources</span>
    <span class="n">surr_realisations</span> <span class="o">=</span> <span class="n">_get_surrogates</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                                        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
                                        <span class="p">[</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">],</span>
                                        <span class="n">n_perm</span><span class="p">,</span>
                                        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>
    <span class="c1"># Calculate surrogate distribution for shd/syn information of both sources.</span>
    <span class="c1"># Note: calling  .estimate_mult does not work here because the PID</span>
    <span class="c1"># estimator returns a dictionary not a single value. We have to get the</span>
    <span class="c1"># shared info and synergy from the dictionary manually.</span>
    <span class="n">surr_dist_shd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_perm</span><span class="p">)</span>
    <span class="n">surr_dist_syn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_perm</span><span class="p">)</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">surr_realisations</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">n_perm</span><span class="p">)</span>
    <span class="n">i_1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i_2</span> <span class="o">=</span> <span class="n">chunk_size</span>
    <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Testing shd and syn information in both sources&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_perm</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">perm {0} of {1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">))</span>
        <span class="n">pid_est</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_pid_estimator</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span>
                                <span class="n">settings</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
                                <span class="n">s1</span><span class="o">=</span><span class="n">source_1_realisations</span><span class="p">,</span>
                                <span class="n">s2</span><span class="o">=</span><span class="n">source_2_realisations</span><span class="p">,</span>
                                <span class="n">t</span><span class="o">=</span><span class="n">surr_realisations</span><span class="p">[</span><span class="n">i_1</span><span class="p">:</span><span class="n">i_2</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">surr_dist_shd</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">pid_est</span><span class="p">[</span><span class="s1">&#39;shd_s1_s2&#39;</span><span class="p">]</span>
        <span class="n">surr_dist_syn</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">pid_est</span><span class="p">[</span><span class="s1">&#39;syn_s1_s2&#39;</span><span class="p">]</span>
        <span class="n">i_1</span> <span class="o">=</span> <span class="n">i_2</span>
        <span class="n">i_2</span> <span class="o">+=</span> <span class="n">chunk_size</span>
    <span class="p">[</span><span class="n">sign_shd</span><span class="p">,</span> <span class="n">p_val_shd</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span><span class="n">statistic</span><span class="o">=</span><span class="n">orig_pid</span><span class="p">[</span><span class="s1">&#39;shd_s1_s2&#39;</span><span class="p">],</span>
                                         <span class="n">distribution</span><span class="o">=</span><span class="n">surr_dist_shd</span><span class="p">,</span>
                                         <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                         <span class="n">tail</span><span class="o">=</span><span class="s1">&#39;one_bigger&#39;</span><span class="p">)</span>
    <span class="p">[</span><span class="n">sign_syn</span><span class="p">,</span> <span class="n">p_val_syn</span><span class="p">]</span> <span class="o">=</span> <span class="n">_find_pvalue</span><span class="p">(</span><span class="n">statistic</span><span class="o">=</span><span class="n">orig_pid</span><span class="p">[</span><span class="s1">&#39;syn_s1_s2&#39;</span><span class="p">],</span>
                                         <span class="n">distribution</span><span class="o">=</span><span class="n">surr_dist_syn</span><span class="p">,</span>
                                         <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                         <span class="n">tail</span><span class="o">=</span><span class="s1">&#39;one_bigger&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">orig_pid</span><span class="p">,</span> <span class="n">sign_shd</span><span class="p">,</span> <span class="n">p_val_shd</span><span class="p">,</span> <span class="n">sign_syn</span><span class="p">,</span> <span class="n">p_val_syn</span><span class="p">]</span></div>


<div class="viewcode-block" id="check_n_perm"><a class="viewcode-back" href="../../idtxl.html#idtxl.stats.check_n_perm">[docs]</a><span class="k">def</span> <span class="nf">check_n_perm</span><span class="p">(</span><span class="n">n_perm</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check if no. permutations is big enough to obtain the requested alpha.</span>

<span class="sd">    Note:</span>
<span class="sd">        The no. permutations must be big enough to theoretically allow for the</span>
<span class="sd">        detection of a p-value that is smaller than the critical alpha level.</span>
<span class="sd">        Otherwise the permutation test is pointless. The smalles possible</span>
<span class="sd">        p-value is 1/n_perm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">n_perm</span> <span class="o">&lt;</span> <span class="n">alpha</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;The number of permutations {0} is to small to test&#39;</span>
                           <span class="s1">&#39; the requested alpha level {1}. The number of &#39;</span>
                           <span class="s1">&#39;permutations must be greater than 1/alpha.&#39;</span>
                           <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n_perm</span><span class="p">,</span> <span class="n">alpha</span><span class="p">))</span></div>


<span class="k">def</span> <span class="nf">_create_surrogate_table</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">idx_test_set</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Create a table of surrogate MI/CMI/TE values.</span>

<span class="sd">    Calculate MI/CMI/TE between surrogates for each source in the test</span>
<span class="sd">    set and the target in the analysis setup using the current conditional in</span>
<span class="sd">    the analysis setup.</span>

<span class="sd">    Args:</span>
<span class="sd">        analysis_setup : MultivariateTE instance</span>
<span class="sd">            information on the current analysis, must contain an attribute</span>
<span class="sd">            settings with entry &#39;permute_in_time&#39;</span>
<span class="sd">        data : Data instance</span>
<span class="sd">            raw data</span>
<span class="sd">        idx_test_set : list of tuples</span>
<span class="sd">            list of indices indicating samples to be used as sources</span>
<span class="sd">        n_perm : int</span>
<span class="sd">            number of permutations for testing</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy array</span>
<span class="sd">            surrogate MI/CMI/TE values, dimensions: (length test set, number of</span>
<span class="sd">            surrogates)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check which permutation type is requested by the calling function.</span>
    <span class="n">permute_in_time</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;permute_in_time&#39;</span><span class="p">]</span>

    <span class="c1"># Create surrogate table.</span>
    <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">creating surrogate table with {0} permutations:&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                                                                    <span class="n">n_perm</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">cand.&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">surr_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_test_set</span><span class="p">),</span> <span class="n">n_perm</span><span class="p">))</span>
    <span class="n">current_value_realisations</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_current_value_realisations</span>
    <span class="n">idx_c</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">idx_test_set</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">VERBOSE</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">{0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_idx_to_lag</span><span class="p">([</span><span class="n">candidate</span><span class="p">])[</span><span class="mi">0</span><span class="p">]),</span>
                  <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        surr_candidate_realisations = np.empty(</span>
<span class="sd">                (data.n_realisations(analysis_setup.current_value) * n_perm,</span>
<span class="sd">                1))</span>
<span class="sd">        i_1 = 0</span>
<span class="sd">        i_2 = data.n_realisations(analysis_setup.current_value)</span>
<span class="sd">        for perm in range(n_perm):</span>
<span class="sd">            # Check the permutation type for the current candidate.</span>
<span class="sd">            if permute_over_replications:</span>
<span class="sd">                sur_temp = data.permute_data(analysis_setup.current_value,</span>
<span class="sd">                                             [candidate])[0]</span>
<span class="sd">            else:</span>
<span class="sd">                [real, repl_idx] = data.get_realisations(</span>
<span class="sd">                                                analysis_setup.current_value,</span>
<span class="sd">                                                [candidate])</span>
<span class="sd">                sur_temp = _permute_realisations(real, repl_idx, perm_range)</span>

<span class="sd">            surr_candidate_realisations[i_1:i_2, ] = sur_temp</span>
<span class="sd">            i_1 = i_2</span>
<span class="sd">            i_2 += data.n_realisations(analysis_setup.current_value)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">is_analytic_null_estimator</span><span class="p">()</span> <span class="ow">and</span>
                <span class="n">permute_in_time</span><span class="p">):</span>
            <span class="c1"># Generate the surrogates analytically</span>
            <span class="n">surr_table</span><span class="p">[</span><span class="n">idx_c</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span>
                                    <span class="n">estimate_surrogates_analytic</span><span class="p">(</span>
                                        <span class="n">n_perm</span><span class="o">=</span><span class="n">n_perm</span><span class="p">,</span>
                                        <span class="n">var1</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">get_realisations</span><span class="p">(</span>
                                                <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span> <span class="p">[</span><span class="n">candidate</span><span class="p">])[</span><span class="mi">0</span><span class="p">],</span>
                                        <span class="n">var2</span><span class="o">=</span><span class="n">current_value_realisations</span><span class="p">,</span>
                                        <span class="n">conditional</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_selected_vars_realisations</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">surr_candidate_realisations</span> <span class="o">=</span> <span class="n">_get_surrogates</span><span class="p">(</span>
                                                 <span class="n">data</span><span class="p">,</span>
                                                 <span class="n">analysis_setup</span><span class="o">.</span><span class="n">current_value</span><span class="p">,</span>
                                                 <span class="p">[</span><span class="n">candidate</span><span class="p">],</span>
                                                 <span class="n">n_perm</span><span class="p">,</span>
                                                 <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>
            <span class="n">surr_table</span><span class="p">[</span><span class="n">idx_c</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">_cmi_estimator</span><span class="o">.</span><span class="n">estimate_mult</span><span class="p">(</span>
                    <span class="n">n_chunks</span><span class="o">=</span><span class="n">n_perm</span><span class="p">,</span>
                    <span class="n">re_use</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;var2&#39;</span><span class="p">,</span> <span class="s1">&#39;conditional&#39;</span><span class="p">],</span>
                    <span class="n">var1</span><span class="o">=</span><span class="n">surr_candidate_realisations</span><span class="p">,</span>  <span class="c1"># too long</span>
                    <span class="n">var2</span><span class="o">=</span><span class="n">current_value_realisations</span><span class="p">,</span>
                    <span class="n">conditional</span><span class="o">=</span><span class="n">analysis_setup</span><span class="o">.</span><span class="n">_selected_vars_realisations</span><span class="p">)</span>
        <span class="n">idx_c</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">surr_table</span>


<span class="k">def</span> <span class="nf">_find_table_max</span><span class="p">(</span><span class="n">table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find maximum for each column of a table.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_find_table_min</span><span class="p">(</span><span class="n">table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find minimum for each column of a table.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_sort_table_min</span><span class="p">(</span><span class="n">table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sort each column in a table in ascending order.&quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">permutation</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">table</span><span class="p">[:,</span> <span class="n">permutation</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">table</span>


<span class="k">def</span> <span class="nf">_sort_table_max</span><span class="p">(</span><span class="n">table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sort each column in a table in descending order.&quot;&quot;&quot;</span>
    <span class="n">table_sorted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">permutation</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">table_sorted</span><span class="p">[:,</span> <span class="n">permutation</span><span class="p">]</span> <span class="o">=</span> <span class="n">utils</span><span class="o">.</span><span class="n">sort_descending</span><span class="p">(</span>
                                            <span class="n">table</span><span class="p">[:,</span> <span class="n">permutation</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">table_sorted</span>


<span class="k">def</span> <span class="nf">_find_pvalue</span><span class="p">(</span><span class="n">statistic</span><span class="p">,</span> <span class="n">distribution</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">tail</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find p-value of a test statistic under some distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        statistic : numeric</span>
<span class="sd">            value to be tested against distribution</span>
<span class="sd">        distribution : numpy array</span>
<span class="sd">            1-dimensional distribution of values, test distribution</span>
<span class="sd">        alpha : float</span>
<span class="sd">            critical alpha level for statistical significance</span>
<span class="sd">        tail : str</span>
<span class="sd">            &#39;one_bigger&#39; for one-tailed testing H1 &gt; H0, &#39;one_smaller&#39; for one-</span>
<span class="sd">            tailed testing H1 &lt; H0, or &#39;two&#39; for two-tailed testing</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool</span>
<span class="sd">            statistical significance</span>
<span class="sd">        float</span>
<span class="sd">            the test&#39;s p-value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">alpha</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s1">&#39;Critical alpha levels needs to be smaller than 1.&#39;</span>
    <span class="k">assert</span> <span class="n">distribution</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;Test distribution must be 1D.&#39;</span>
    <span class="n">check_n_perm</span><span class="p">(</span><span class="n">distribution</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">tail</span> <span class="o">==</span> <span class="s1">&#39;one_bigger&#39;</span><span class="p">:</span>
        <span class="n">pvalue</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">distribution</span> <span class="o">&gt;=</span> <span class="n">statistic</span><span class="p">)</span> <span class="o">/</span> <span class="n">distribution</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">tail</span> <span class="o">==</span> <span class="s1">&#39;one_smaller&#39;</span><span class="p">:</span>
        <span class="n">pvalue</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">distribution</span> <span class="o">&lt;=</span> <span class="n">statistic</span><span class="p">)</span> <span class="o">/</span> <span class="n">distribution</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">tail</span> <span class="o">==</span> <span class="s1">&#39;two&#39;</span><span class="p">:</span>
        <span class="n">p_bigger</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">distribution</span> <span class="o">&gt;=</span> <span class="n">statistic</span><span class="p">)</span> <span class="o">/</span> <span class="n">distribution</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">p_smaller</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">distribution</span> <span class="o">&lt;=</span> <span class="n">statistic</span><span class="p">)</span> <span class="o">/</span> <span class="n">distribution</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pvalue</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">p_bigger</span><span class="p">,</span> <span class="n">p_smaller</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s1">&#39;Unkown value for &#39;&#39;tail&#39;&#39;, can be &#39;&#39;one_bigger&#39;&#39;, &#39;</span>
                          <span class="s1">&#39; &#39;&#39;one_smaller&#39;&#39;, or &#39;&#39;two&#39;&#39;): {0}.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tail</span><span class="p">)))</span>

    <span class="c1"># If the statistic is larger than all values in the test distribution, set</span>
    <span class="c1"># the p-value to the smallest possible value 1/n_perm.</span>
    <span class="k">if</span> <span class="n">pvalue</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">pvalue</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">distribution</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">significance</span> <span class="o">=</span> <span class="n">pvalue</span> <span class="o">&lt;</span> <span class="n">alpha</span>

    <span class="k">return</span> <span class="n">significance</span><span class="p">,</span> <span class="n">pvalue</span>


<span class="k">def</span> <span class="nf">_sufficient_replications</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Test if no. replications is high enough for surrogate creation.</span>

<span class="sd">    Test if the number of replications is high enough to allow for the required</span>
<span class="sd">    number of permutations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">n_replications</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n_perm</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>


<span class="k">def</span> <span class="nf">_get_surrogates</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">current_value</span><span class="p">,</span> <span class="n">idx_list</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">,</span> <span class="n">perm_settings</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return surrogate data for statistical testing.</span>

<span class="sd">    Calls surrogate generation methods of the data instance. The method for</span>
<span class="sd">    surrogate generation depends on whether sufficient replications of the data</span>
<span class="sd">    exists. If the number of replications is high enough (reps! &gt;</span>
<span class="sd">    n_permutations), surrogates are created by shuffling data over replications</span>
<span class="sd">    (while keeping the temporal order of samples intact). If the number of</span>
<span class="sd">    replications is too low, samples are shuffled over time (while keeping the</span>
<span class="sd">    order of replications intact). The latter method can be forced by setting</span>
<span class="sd">    &#39;permute_in_time&#39; to True in &#39;perm_settings&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">        data : Data instance</span>
<span class="sd">            raw data for analysis</span>
<span class="sd">        current_value : tuple</span>
<span class="sd">            index of the current value in current analysis, has to have the</span>
<span class="sd">            form (idx process, idx sample)</span>
<span class="sd">        idx_list : list of tuples</span>
<span class="sd">            list of variables, for which surrogates have to be created</span>
<span class="sd">        n_perm : int</span>
<span class="sd">            number of permutations</span>
<span class="sd">        perm_settings : dict</span>
<span class="sd">            settings for surrogate creation by shuffling samples over time, set</span>
<span class="sd">            &#39;permute_in_time&#39; to True to create surrogates by shuffling data</span>
<span class="sd">            over time. See Data.permute_samples() for settings for surrogate</span>
<span class="sd">            creation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy array</span>
<span class="sd">            surrogate data with dimensions</span>
<span class="sd">            (realisations * n_perm) x len(idx_list)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Allocate memory for surrogates</span>
    <span class="n">n_realisations</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">n_realisations</span><span class="p">(</span><span class="n">current_value</span><span class="p">)</span>
    <span class="n">surrogates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_realisations</span> <span class="o">*</span> <span class="n">n_perm</span><span class="p">,</span>
                           <span class="nb">len</span><span class="p">(</span><span class="n">idx_list</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span>

    <span class="c1"># Check if the user requested to permute samples in time and not over</span>
    <span class="c1"># replications</span>
    <span class="n">permute_in_time</span> <span class="o">=</span> <span class="n">perm_settings</span><span class="p">[</span><span class="s1">&#39;permute_in_time&#39;</span><span class="p">]</span>

    <span class="c1"># Generate surrogates by permuting over replications if possible (no.</span>
    <span class="c1"># replications needs to be sufficient); else permute samples over time.</span>
    <span class="n">i_1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">i_2</span> <span class="o">=</span> <span class="n">n_realisations</span>
    <span class="c1"># permute samples</span>
    <span class="k">if</span> <span class="n">permute_in_time</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_perm</span><span class="p">):</span>
            <span class="n">surrogates</span><span class="p">[</span><span class="n">i_1</span><span class="p">:</span><span class="n">i_2</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">permute_samples</span><span class="p">(</span><span class="n">current_value</span><span class="p">,</span>
                                                         <span class="n">idx_list</span><span class="p">,</span>
                                                         <span class="n">perm_settings</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">i_1</span> <span class="o">=</span> <span class="n">i_2</span>
            <span class="n">i_2</span> <span class="o">+=</span> <span class="n">n_realisations</span>

    <span class="k">else</span><span class="p">:</span>  <span class="c1"># permute replications</span>
        <span class="k">assert</span> <span class="n">_sufficient_replications</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">),</span> <span class="p">(</span>
                <span class="s1">&#39;Not enough replications for surrogate creation.&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_perm</span><span class="p">):</span>
            <span class="n">surrogates</span><span class="p">[</span><span class="n">i_1</span><span class="p">:</span><span class="n">i_2</span><span class="p">,</span> <span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">permute_replications</span><span class="p">(</span><span class="n">current_value</span><span class="p">,</span>
                                                              <span class="n">idx_list</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">i_1</span> <span class="o">=</span> <span class="n">i_2</span>
            <span class="n">i_2</span> <span class="o">+=</span> <span class="n">n_realisations</span>
    <span class="k">return</span> <span class="n">surrogates</span>


<span class="k">def</span> <span class="nf">_generate_spectral_surrogates</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">,</span> <span class="n">perm_settings</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate surrogate data for statistical testing of spectral TE.</span>

<span class="sd">    The method for surrogate generation depends on whether sufficient</span>
<span class="sd">    replications of the data exists. If the number of replications is high</span>
<span class="sd">    enough (reps! &gt; n_permutations), surrogates are created by shuffling data</span>
<span class="sd">    over replications (while keeping the temporal order of samples intact). If</span>
<span class="sd">    the number of replications is too low, samples are shuffled over time</span>
<span class="sd">    (while keeping the order of replications intact).</span>

<span class="sd">    Args:</span>
<span class="sd">        data : Data instance</span>
<span class="sd">            raw data for analysis</span>
<span class="sd">        scale : int</span>
<span class="sd">            index of the scale to be shuffled</span>
<span class="sd">        n_perm : int</span>
<span class="sd">            number of permutations</span>
<span class="sd">        perm_settings : dict</span>
<span class="sd">            settings for surrogate creation by shuffling samples over time</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy array</span>
<span class="sd">            surrogate data with dimensions</span>
<span class="sd">            (realisations * n_perm) x len(idx_list)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Allocate memory for surrogates</span>
    <span class="n">surrogates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">n_samples</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">n_replications</span><span class="p">,</span>
                           <span class="n">n_perm</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">data_type</span><span class="p">)</span>
    <span class="n">permute_in_time</span> <span class="o">=</span> <span class="n">perm_settings</span><span class="p">[</span><span class="s1">&#39;permute_in_time&#39;</span><span class="p">]</span>
    <span class="c1"># Generate surrogates by permuting over replications if possible (no.</span>
    <span class="c1"># replications needs to be sufficient); else permute samples over time.</span>
    <span class="k">if</span> <span class="n">permute_in_time</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_perm</span><span class="p">):</span>
            <span class="n">surrogates</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">perm</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">slice_permute_samples</span><span class="p">(</span>
                                                    <span class="n">scale</span><span class="p">,</span> <span class="n">perm_settings</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">_sufficient_replications</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_perm</span><span class="p">):</span>
            <span class="n">surrogates</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">perm</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">slice_permute_replications</span><span class="p">(</span><span class="n">scale</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">surrogates</span>


<span class="k">def</span> <span class="nf">_check_permute_in_time</span><span class="p">(</span><span class="n">analysis_setup</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Set defaults for permuting samples in time.</span>

<span class="sd">    The default for creating surrogate data is the permutation of original data</span>
<span class="sd">    over replications (such that the temporal ordering of samples stays</span>
<span class="sd">    intact). The function checks if this default can be used given the</span>
<span class="sd">    requested number of permutations and the number of replications in the</span>
<span class="sd">    data.</span>

<span class="sd">    The function tries to set the setting &#39;permute_in_time&#39; to its default</span>
<span class="sd">    &#39;False&#39; if no value for &#39;permute_in_time&#39; was provided by the user. If the</span>
<span class="sd">    number of replications is insufficient to generate the requested number of</span>
<span class="sd">    permutations, the function sets &#39;permute_in_time&#39; to true such that</span>
<span class="sd">    surrogates are created by permuting samples in time (if not requested</span>
<span class="sd">    otherwise the &#39;perm_type&#39; is set to &#39;random&#39;, see documentation of</span>
<span class="sd">    Data().permute_samples() for further settings).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;permute_in_time&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;permute_in_time&#39;</span><span class="p">]</span> <span class="ow">and</span>
            <span class="ow">not</span> <span class="n">_sufficient_replications</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_perm</span><span class="p">)):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">WARNING: Number of replications is not sufficient to generate &#39;</span>
              <span class="s1">&#39;the desired number of surrogates. Permuting samples in time &#39;</span>
              <span class="s1">&#39;instead.&#39;</span><span class="p">)</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;permute_in_time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">if</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;permute_in_time&#39;</span><span class="p">]:</span>
        <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;perm_type&#39;</span><span class="p">,</span> <span class="s1">&#39;random&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">analysis_setup</span><span class="o">.</span><span class="n">settings</span><span class="p">[</span><span class="s1">&#39;permute_in_time&#39;</span><span class="p">]</span>
</pre></div>

                </div>
              </div>
            </div>
          </div>
        </div>
         
<div class="col-md-3 hidden-xs" id="sidebar-wrapper">
  <div class="sidebar hidden-xs" role="navigation" aria-label="main navigation">
<div id="searchbox" role="search">
  <h3>Quick search</h3>
  <form class="search form-inline" action="../../search.html" method="get">
      <div class="input-append input-group">
        <input type="text" class="search-query form-control" name="q" placeholder="Search...">
        <span class="input-group-btn">
        <input type="submit" class="btn" value="Go" />
        </span>
      </div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
  </div>
</div> 
        
      </div><!-- /row -->

      <!-- row -->
      <div class="row footer-relbar">
<div id="navbar-related" class=" related navbar navbar-default" role="navigation" aria-label="related navigation">
  <div class="navbar-inner">
    <ul class="nav navbar-nav ">
        <li><a href="../../index.html">IDTxl 0.1 documentation</a></li>
    </ul>
<ul class="nav navbar-nav pull-right hidden-xs hidden-sm">
      
        <li><a href="../../py-modindex.html" title="Python Module Index" >modules</a></li>
        <li><a href="../../genindex.html" title="General Index" >index</a></li>
        <li><a href="../index.html" >Module code</a></li>
        <li><a href="#">top</a></li> 
      
    </ul>
  </div>
</div>
      </div><!-- /row -->

      <!-- footer -->
      <footer role="contentinfo">
          &copy; Copyright 2016, Patricia Wollstadt, Michael Wibral, Joe T. Lizier, Finn Connor, Raul Vicente.
        Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.6.
      </footer>
      <!-- /footer -->

    </div>
    <!-- /container -->

  </body>
</html>